# Vector Driver UAF

## 1. Vulnerability Analysis

### 1.1 User-After-Free (UAF) in `ALLOCATE_VECTOR`
The `ALLOCATE_VECTOR` ioctl handler allocates a `vector_t` object and assigns its pointer to the global `vecs` array before validating user-provided data. If `copy_from_user` fails, the memory is freed using `kmem_cache_free`, but the pointer in `vecs[fdx]` is not nullified.

**Vulnerable Code Path (`vector.c`):**
```c
vecs[fdx] = kmem_cache_alloc(vecache_cache, GFP_KERNEL);
...
if (copy_from_user(&vecs[fdx]->vec, ...)) {
    kmem_cache_free(vecache_cache, vecs[fdx]); // Object freed
    // vecs[fdx] remains a dangling pointer
    goto unlock_leave; 
}
```

### 1.2 Slab Characteristics
The driver creates a dedicated slab cache with the `SLAB_NO_MERGE` flag:
```c
vecache_cache = kmem_cache_create("vecache", sizeof(vector_t), 0, SLAB_NO_MERGE, NULL);
```
While this prevents merging with general-purpose `kmalloc` caches, it does not prevent self-reclamation. Subsequent allocations of the same size (256 bytes) within this cache will reuse the recently freed slot.

## 2. Exploitation Strategy

### 2.1 Memory Aliasing
By triggering the `copy_from_user` failure (e.g., providing an invalid user address), a dangling pointer is established at `vecs[0]`. A subsequent successful `ALLOCATE_VECTOR` call reclaims this memory slot at `vecs[1]`. Consequently, `vecs[0]` and `vecs[1]` become aliases for the same kernel heap address.

### 2.2 Arbitrary Write Primitive
The `UPDATE_VECTOR` ioctl allows writing to the `vec` array within a `vector_t` object. The `idx` parameter is a signed 64-bit integer (`int64_t`).

**Data Structure Layout:**
- `destructor` (offset 0)
- `inuse` (offset 8)
- `vec[0]` (offset 16)

**Logic Bypass:**
The bounds check `if (vecarg.idx < 0 || vecarg.idx >= 30)` is intended to restrict access. However, by using the dangling pointer `vecs[0]`, we can still issue `UPDATE_VECTOR` calls. Specifically, an `idx` of `-2` targets the `destructor` field:
`Offset = 16 + (-2 * 8) = 0`

### 2.3 Privilege Escalation Gadget
The exploit utilizes a gadget identified at `0xffffffc080075a78` in the target kernel. This gadget loads the `init_cred` address and branches to `commit_creds`.

**Gadget Disassembly:**
```text
ffffffc080075a78: adrp x0, 0xffffffc081932000
ffffffc080075a7c: add  x0, x0, #1520           ; x0 = &init_cred
ffffffc080075a80: bl   0xffffffc0800750b4      ; bl commit_creds
```

Executing this gadget:
1.  Sets the process credentials to `init_cred` (UID 0).
2.  Assumes the `init_cred` SELinux context, bypassing enforcement for file access.

## 3. Execution Flow
1.  **Initialize:** Open `/dev/vector`.
2.  **Trigger UAF:** Call `ALLOCATE_VECTOR` with an invalid `vecp` to create a dangling pointer at `vecs[0]`.
3.  **Reclaim:** Call `ALLOCATE_VECTOR` with valid data to reclaim the memory at `vecs[1]`.
4.  **Hijack:** Use `UPDATE_VECTOR` on `fdx 0` with `idx -2` to set `vecs[1]->destructor` to `0xffffffc080075a78`.
5.  **Synchronize:** Fork a child process to wait for the UID change.
6.  **Trigger:** Call `DESTROY_VECTOR` on `fdx 1`. This executes `vecs[1]->destructor(vecs[1])`, triggering the gadget.
7.  **Exfiltrate:** The child process, now root with `init_cred` context, reads `/data/vendor/secret/flag.txt`.

## 4. Final Exploit Code
The complete implementation is provided in `exploit.c`.
